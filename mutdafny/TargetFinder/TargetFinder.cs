using Microsoft.Dafny;

namespace MutDafny.TargetFinder;

public abstract class TargetFinder(int mutationTargetPos, ErrorReporter reporter)
{
    public Statement? TargetStatement { get; protected set; }
    public Expression? TargetExpression { get; protected set; }

    public void Find(ModuleDefinition module)
    {
        // only visit modules that may contain the mutation target
        if (module.EndToken.pos == 0 || // default module
            IsWorthVisiting(module.StartToken.pos, module.EndToken.pos)) {
            HandleDefaultClassDecl(module);
            if (TargetFound()) return;
            HandleSourceDecls(module);
        }
    }
    
    protected bool IsWorthVisiting(int tokenStartPos, int tokenEndPos)
    {
        return tokenStartPos <= mutationTargetPos && 
               mutationTargetPos <= tokenEndPos;
    }

    private void HandleDefaultClassDecl(ModuleDefinition module)
    {
        if (module.DefaultClass == null) return;
        
        foreach (var member in module.DefaultClass.Members) {
            // only visit members that may contain the mutation target
            if (!IsWorthVisiting(member.StartToken.pos, member.EndToken.pos)) continue;
            if (member is Method m) {
                HandleMethod(m);
                if (TargetFound()) return;
            }
            // TODO: check functions and predicates that aren't used in spec
        }
    }

    private void HandleSourceDecls(ModuleDefinition module)
    {
        foreach (var decl in module.SourceDecls) {
            // only visit declarations that may contain the mutation target
            if (!IsWorthVisiting(decl.StartToken.pos, decl.EndToken.pos)) continue;
            if (decl is ClassDecl classDecl) {
                HandleClassDecl(classDecl);   
                if (TargetFound()) return;
            }
        }
    }

    private void HandleClassDecl(ClassDecl classDecl)
    {
        foreach (var member in classDecl.Members) {
            // only visit members that may contain the mutation target
            if (!IsWorthVisiting(member.StartToken.pos, member.EndToken.pos)) continue;
            if (member is Method m) {
                HandleMethod(m);  
                if (TargetFound()) return;
            }
            // TODO: check functions and predicates that aren't used in spec
        }
    }

    private void HandleMethod(Method method)
    {
        var methodToken = new AutoGeneratedOrigin(method.Origin);
        reporter.Info(MessageSource.Rewriter, methodToken, 
            "This method contains the mutation target"
        );
        
        if (method.Body == null) return;
        HandleBlock(method.Body);
        if (TargetFound()) {
            var statementToken = new AutoGeneratedOrigin(GetTarget().Origin);
            reporter.Info(MessageSource.Rewriter, statementToken, 
                "This statement contains the mutation target"
            );
        }
    }
    
    protected abstract void HandleStatement(Statement statement);

    protected void HandleBlock(BlockStmt blockStmt)
    {
        foreach (var stmt in blockStmt.Body) {
            if (IsWorthVisiting(stmt.StartToken.pos, stmt.EndToken.pos)) {
                HandleStatement(stmt);
            }
            if (TargetFound()) return;
        }
    }

    private bool TargetFound()
    {
        return TargetStatement != null || TargetExpression != null;
    }

    private INode? GetTarget()
    {
        if (TargetExpression != null) return TargetExpression;
        return TargetStatement;
    }
}