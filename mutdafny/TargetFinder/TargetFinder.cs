using Microsoft.Dafny;

namespace MutDafny.TargetFinder;

public abstract class TargetFinder(int mutationTargetPos, ErrorReporter reporter)
{
    public static BlockStmt? TargetBlock { get; private set; }
    public static Statement? TargetStatement { get; private set; }

    public void Find(ModuleDefinition module)
    {
        // only visit modules that may contain the mutation target
        if (module.EndToken.pos == 0 || // default module
            IsWorthVisiting(module.StartToken.pos, module.EndToken.pos)) {
            TargetStatement = HandleDefaultClassDecl(module) ?? HandleSourceDecls(module);
        }
    }
    
    protected bool IsWorthVisiting(int tokenStartPos, int tokenEndPos)
    {
        return tokenStartPos <= mutationTargetPos && 
               mutationTargetPos <= tokenEndPos;
    }

    private Statement? HandleDefaultClassDecl(ModuleDefinition module)
    {
        if (module.DefaultClass == null) return null;
        
        Statement? statement = null;
        foreach (var member in module.DefaultClass.Members) {
            if (member is Method m) {
                // only visit methods that may contain the mutation target
                if (IsWorthVisiting(m.StartToken.pos, m.EndToken.pos)) { 
                    statement = HandleMethod(m);
                    TargetBlock = m.Body; 
                }
            }
            // TODO: check functions and predicates that aren't used in spec
            
            if (statement != null) return statement;
        }
        return statement;
    }

    private Statement? HandleSourceDecls(ModuleDefinition module)
    {
        Statement? statement = null;
        foreach (var decl in module.SourceDecls) {
            if (decl is ClassDecl classDecl) {
                // only visit classes that may contain the mutation target
                if (IsWorthVisiting(classDecl.StartToken.pos, classDecl.EndToken.pos)) { 
                    statement = HandleClassDecl(classDecl);   
                }
            }
            if (statement != null) return statement;
        }
        return statement;
    }

    private Statement? HandleClassDecl(ClassDecl classDecl)
    {
        Statement? statement = null;
        foreach (var member in classDecl.Members) {
            if (member is Method m) {
                // only visit methods that may contain the mutation target
                if (IsWorthVisiting(m.StartToken.pos, m.EndToken.pos)) { 
                    statement = HandleMethod(m);   
                }
            }
            // TODO: check functions and predicates that aren't used in spec
            
            if (statement != null) return statement;
        }
        return statement;
    }

    private Statement? HandleMethod(Method method)
    {
        var methodToken = new AutoGeneratedOrigin(method.Origin);
        reporter.Info(MessageSource.Rewriter, methodToken, 
            "This method contains the mutation target"
        );
        
        var statement = method.Body != null ? HandleBlock(method.Body) : null;
        if (statement != null) {
            var statementToken = new AutoGeneratedOrigin(statement.Origin);
            reporter.Info(MessageSource.Rewriter, statementToken, 
                "This statement contains the mutation target"
            );
        }
        return statement;
    }
    
    protected abstract Statement? HandleStatement(Statement statement);

    protected Statement? HandleBlock(BlockStmt blockStmt)
    {
        TargetBlock = blockStmt;
        Statement? statement = null;
        foreach (var stmt in blockStmt.Body) {
            if (IsWorthVisiting(stmt.StartToken.pos, stmt.EndToken.pos)) {
                statement = HandleStatement(stmt);
            }
            if (statement != null) return statement;
        }
        return statement;
    }
}