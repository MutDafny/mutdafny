using Microsoft.Dafny;

namespace MutDafny.TargetFinder;

public abstract class TargetFinder(int mutationTargetPos, ErrorReporter reporter)
{
    public Statement? TargetStatement { get; protected set; }
    public Expression? TargetExpression { get; protected set; }

    public void Find(ModuleDefinition module) {
        // only visit modules that may contain the mutation target
        if (module.EndToken.pos == 0 || // default module
            IsWorthVisiting(module.StartToken.pos, module.EndToken.pos)) {
            HandleDefaultClassDecl(module);
            if (TargetFound()) return;
            HandleSourceDecls(module);

            INode? target;
            if (TargetFound() && (target = GetTarget()) != null) {
                var targetToken = new AutoGeneratedOrigin(target.Origin);
                reporter.Info(MessageSource.Rewriter, targetToken, 
                    $"This {GetTargetType()} contains the mutation target"
                );
            }
        }
    }
    
    protected bool IsWorthVisiting(int tokenStartPos, int tokenEndPos) {
        return tokenStartPos <= mutationTargetPos && 
               mutationTargetPos <= tokenEndPos;
    }

    private void HandleDefaultClassDecl(ModuleDefinition module) {
        if (module.DefaultClass == null) return;
        HandleMemberDecls(module.DefaultClass);
    }

    private void HandleSourceDecls(ModuleDefinition module) {
        foreach (var decl in module.SourceDecls) {
            // only visit declarations that may contain the mutation target
            if (!IsWorthVisiting(decl.StartToken.pos, decl.EndToken.pos)) continue;
            if (decl is TopLevelDeclWithMembers declWithMembers) { // includes class, trait, datatype, etc.
                HandleMemberDecls(declWithMembers);   
            }
            if (decl is IteratorDecl itDecl) {
                HandleBlock(itDecl.Body);
            } else if (decl is NewtypeDecl newTpDecl) {
                HandleExpression(newTpDecl.Constraint);
            } else if (decl is SubsetTypeDecl subTpDecl) {
                HandleExpression(subTpDecl.Constraint);
                if (subTpDecl is NonNullTypeDecl nNullTpDecl) {
                    HandleMemberDecls(nNullTpDecl.Class);
                }
            }
            
            if (TargetFound()) return;
        }
    }

    private void HandleMemberDecls(TopLevelDeclWithMembers decl) {
        foreach (var member in decl.Members) {
            // only visit members that may contain the mutation target
            if (!IsWorthVisiting(member.StartToken.pos, member.EndToken.pos)) continue;
            if (member is Method m) { // includes constructor
                HandleMethod(m);  
            } else if (member is Function func) { // includes predicates
                // TODO: only consider functions and predicates that aren't used in spec
                HandleFunction(func);
            } else if (member is ConstantField cf) {
                HandleExpression(cf.Rhs);
            }

            if (TargetFound()) return;
        }
    }

    protected void HandleMethod(Method method) {
        var methodToken = new AutoGeneratedOrigin(method.Origin);
        reporter.Info(MessageSource.Rewriter, methodToken, 
            "This method contains the mutation target"
        );
        
        if (method.Body == null) return;
        HandleBlock(method.Body);
    }

    private void HandleFunction(Function function) {
        var functionToken = new AutoGeneratedOrigin(function.Origin);
        reporter.Info(MessageSource.Rewriter, functionToken, 
            $"This {function.WhatKind} contains the mutation target"
        );
        
        if (function.Body == null) return;
        HandleExpression(function.Body);
    }
    
    protected abstract void HandleStatement(Statement statement);
    
    protected abstract void HandleExpression(Expression expression);

    protected void HandleBlock(BlockStmt blockStmt) {
        HandleBlock(blockStmt.Body);
    }
    
    protected void HandleBlock(List<Statement> statements) {
        foreach (var stmt in statements) {
            if (IsWorthVisiting(stmt.StartToken.pos, stmt.EndToken.pos)) {
                HandleStatement(stmt);
            }
            if (TargetFound()) return;
        }
    }

    protected bool TargetFound() {
        return TargetStatement != null || TargetExpression != null;
    }

    private INode? GetTarget() {
        if (TargetExpression != null) return TargetExpression;
        return TargetStatement;
    }

    private string GetTargetType() {
        return TargetExpression != null ? "expression" : "statement";
    }
}