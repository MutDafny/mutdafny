using Microsoft.Dafny;

namespace MutDafny.Mutator;

// this type of finder is used to find the statement in which specific binary operators are used
public class BinaryOpMutator(int mutationTargetPos, string op, ErrorReporter reporter) : Mutator(mutationTargetPos, reporter)
{
    protected override void VisitExpression(BinaryExpr bExpr) {
        if (IsTarget(bExpr)) {
            TargetExpression = bExpr;
            Mutate(bExpr);
            if (ChainingExprParent != null) {
                MutateChainingParent(bExpr, ChainingExprParent);
            }
            return;
        }
        base.VisitExpression(bExpr);
    }
    
    private void Mutate(BinaryExpr bExpr) {
        bExpr.Op = (BinaryExpr.Opcode)Enum.Parse(typeof(BinaryExpr.Opcode), op);
        
        var binaryExprToken = new AutoGeneratedOrigin(bExpr.Center);
        Reporter.Info(MessageSource.Rewriter, binaryExprToken, $"Operation mutated to {op}");
    }
    
    // chaining expressions require additional mutation to ensure consistency upon program serialization
    private void MutateChainingParent(BinaryExpr bExpr, ChainingExpression cExpr) {
        foreach (var (e, i) in cExpr.Operands.Select((e, i) => (e, i))) {
            if (e.Center.pos != bExpr.E0.Center.pos) continue;
            // if the lhs operand is at position i of the operands list
            // then the operator is at position i of the operators list
            cExpr.Operators[i] = (BinaryExpr.Opcode)Enum.Parse(typeof(BinaryExpr.Opcode), op);
            
            var binaryExprToken = new AutoGeneratedOrigin(e.Center);
            Reporter.Info(MessageSource.Rewriter, binaryExprToken, $"Operation mutated to {op}");
        }
    }
    
    private bool IsTarget(BinaryExpr expr) {
        return expr.Center.pos == MutationTargetPos;
    }
}